#+TITLE:       configuration.options README
#+AUTHOR:      Jan Moringen
#+EMAIL:       jmoringe@techfak.uni-bielefeld.de
#+DESCRIPTION:
#+KEYWORDS:    common lisp, options, configuration
#+LANGUAGE:    en

* Introduction
  The =configuration.options= system provides
  + data structures and functions for hierarchical configuration
    schemata and options
  + sources of option values (builtin sources are configuration files,
    environment variables and commandline options)
  + and handling of changes of option values
  All of these aspects are extensible via protocols.

  #+ATTR_HTML: :alt "build status image" :title Build Status :align right
  [[https://travis-ci.org/scymtym/configuration.options][https://travis-ci.org/scymtym/configuration.options.svg]]

* STARTED Tutorial
  Implementing configuration processing using the
  =configuration.options= system involves at least three steps
  1. [[*Specifying a Schema]]
  2. [[*Constructing and Populating a Configuration]] based on the schema
  3. Querying options in the constructed configuration

** Names
   Since options (and the corresponding schema items) are organized
   into a hierarchy, option names are a sequence of multiple
   components. The notation =COMPONENT₁.COMPONENT₂.…= is used when
   representing names as strings.

   "Wildcard names" are names in which one or more components is
   ~:wild~ or ~:wild-inferiors~.

   The following functions deal with names:
   #+BEGIN_SRC lisp  :results values :exports results :colnames '("Form" "Result")
     (mapcar (lambda (example)
               (destructuring-bind (function arguments) example
                 (let ((*package* (find-package :configuration.options)))
                   (list (format nil "(~(~A~)~{ ~S~})" (symbol-name function) arguments)
                         (prin1-to-string (apply function arguments))))))
             `((configuration.options:parse-name      ("a.b.\"c.d\""))
               (configuration.options:make-name       ("a.b.c"))
               (configuration.options:make-name       ("a.*.c"))
               (configuration.options:make-name       ("a.**.c"))
               (configuration.options:make-name       (("a" "b" "c")))
               (configuration.options:name-components (,(configuration.options:make-name "a.**.c")))
               (configuration.options:name-equal      (,(configuration.options:make-name "a.b.c")
                                                        ,(configuration.options:make-name "d.e.f")))
               (configuration.options:name-matches    (,(configuration.options:make-name "d.**.g")
                                                        ,(configuration.options:make-name "d.e.f.g")))
               (configuration.options:name-equal      (,(configuration.options:make-name "a.b.c")
                                                        ,(configuration.options:make-name "d.e.f")))
               (configuration.options:merge-names     (,(configuration.options:make-name "a.b.c")
                                                       ,(configuration.options:make-name "d.e.f")))))
   #+END_SRC

   #+RESULTS:
   | Form                                                                  | Result                               |
   |-----------------------------------------------------------------------+--------------------------------------|
   | (parse-name "a.b.\"c.d\"")                                            | ("a" "b" "c.d")                      |
   | (make-name "a.b.c")                                                   | ("a" "b" "c")                        |
   | (make-name "a.*.c")                                                   | #<WILDCARD-NAME a.*.c {100D70EF23}>  |
   | (make-name "a.**.c")                                                  | #<WILDCARD-NAME a.**.c {100D712923}> |
   | (make-name ("a" "b" "c"))                                             | ("a" "b" "c")                        |
   | (name-components #<WILDCARD-NAME a.**.c {100D6E5FE3}>)                | ("a" :WILD-INFERIORS "c")            |
   | (name-equal ("a" "b" "c") ("d" "e" "f"))                              | NIL                                  |
   | (name-matches #<WILDCARD-NAME d.**.g {100D6EFFC3}> ("d" "e" "f" "g")) | T                                    |
   | (name-equal ("a" "b" "c") ("d" "e" "f"))                              | NIL                                  |
   | (merge-names ("a" "b" "c") ("d" "e" "f"))                             | ("a" "b" "c" "d" "e" "f")            |

** Specifying a Schema
   A schema can be defined in multiple ways:

   + "Manually" via multiple function and method calls
   + Declaratively using ~configuration.options:eval-schema-spec~
   + Declaratively using ~configuration.options:define-schema~

   Since the third method is likely the most commonly used (and uses
   the same syntax as the second method), it is probably sufficient to
   only discuss ~configuration.options:define-schema~. Here is an
   example:
   #+BEGIN_SRC lisp :results silent :exports both
     (configuration.options:define-schema *my-schema*
       "Configuration schema for my program."
       ("logging"
        ("appender"                :type    '(member :file :standard-output)
                                   :default :standard-output
                                   :documentation
                                   "Appender to use.")
        ((:wild-inferiors "level") :type    '(member :info :warning :error)
                                   :documentation
                                   "Package/module/component log level.")))
   #+END_SRC
   The above code creates a schema object and stores it in the
   parameter ~*my-schema*~. The schema consists of two items:

   1. ~logging.appender~ with allowed values ~:file~ and
      ~:standard-output~ and default value ~:standard-output~

   2. a "template" option named =logging.**.level= with allowed values
      ~:info~, ~:warning~ and ~:error~ and without a default value

   #+BEGIN_SRC lisp :results output :exports both
     (describe *my-schema*)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   <root>
   │ Configuration schema for my program.
   └─logging
     ├─appender
     │   Type    (MEMBER FILE STANDARD-OUTPUT)
     │   Default :STANDARD-OUTPUT
     │   Appender to use.
     └─**
       └─level
           Type    (MEMBER INFO WARNING ERROR)
           Default <no default>
           Package/module/component log level.
   #+end_example

*** TODO Sub-schemata

** Constructing and Populating a Configuration
   Configurations are created from schemata by first creating an empty
   configuration object and then populating it with option objects
   corresponding to schema item objects in the schema:

   #+BEGIN_SRC lisp :results silent :exports both
     (defparameter *my-configuration* (configuration.options:make-configuration *my-schema*))
   #+END_SRC

   The created configuration is empty:

   #+BEGIN_SRC lisp :results output :exports both
   (describe *my-configuration*)
   (format t "^ empty configuration (no output)~%")
   #+END_SRC

   #+RESULTS:
   : ^ empty configuration (no output)

   There are several ways to create option objects from schema item
   objects:

   1. "Manually", options can be created using the ~make-option~
      generic function (this also works if the corresponding to schema
      items have wild names):

      #+BEGIN_SRC lisp :exports both
        (let* ((name        "logging.mypackage.myparser.level")
               (schema-item (configuration.options:find-option
                             name *my-schema*
                             :interpret-wildcards? :container)))
          (setf (configuration.options:find-option name *my-configuration*)
                (configuration.options:make-option schema-item name)))
      #+END_SRC

      #+RESULTS:
      : #<STANDARD-OPTION  logging.mypackage.myparser.level: (MEMBER INFO WARNING ERROR) <no value> {100B8A4FE3}>

      Note that the schema item named =logging.**.level= matches the
      requested name because of its ~:wild-inferiors~ name
      component. Also note that creating an option object does not
      automatically assign a value to it (even if the schema item
      specifies a default value).

      The schema item lookup and ~make-option~ call in the above code
      can be done automatically, shortening the example to:

      #+BEGIN_SRC lisp :exports both
        (configuration.options:find-option
         "logging.mypackage.mylexer.level" *my-configuration*
         :if-does-not-exist :create)
      #+END_SRC

      #+RESULTS:
      : #<STANDARD-OPTION  logging.mypackage.mylexer.level: (MEMBER INFO WARNING ERROR) <no value> {100B8DD5C3}>

   2. Using a "synchronizer" which integrates data from sources such
      as configuration files into configuration objects:

      #+BEGIN_SRC lisp :results silent :exports both
        (let ((synchronizer (make-instance 'configuration.options:standard-synchronizer
                                           :target *my-configuration*))
              (source       (configuration.options.sources:make-source :defaults)))
          (configuration.options.sources:initialize source *my-schema*)
          (configuration.options.sources:process source synchronizer))
      #+END_SRC

      The above example uses the simple "default values" source which
      instantiates option objects for all schema items with non-wild
      names and sets their values to the respective default values (if
      any) stored in corresponding schema items.

   After creating these option objects, the configuration looks like
   this:

   #+BEGIN_SRC lisp :results output :exports both
     (describe *my-configuration*)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   <root>
   └─logging
     ├─appender
     │   Type    (MEMBER FILE STANDARD-OUTPUT)
     │   Default :STANDARD-OUTPUT
     │   Value   :STANDARD-OUTPUT
     │   Sources DEFAULT:
     │             :STANDARD-OUTPUT
     │   Appender to use.
     └─mypackage
       ├─mylexer
       │ └─level
       │     Type    (MEMBER INFO WARNING ERROR)
       │     Default <no default>
       │     Value   <no value>
       │     Package/module/component log level.
       └─myparser
         └─level
             Type    (MEMBER INFO WARNING ERROR)
             Default <no default>
             Value   <no value>
             Package/module/component log level.
   #+end_example

   In a more realistic setting, populating the configuration would be
   done exclusively using a synchronizer but with a "cascade" of
   sources [fn:1] instead of just the "default values" source.

** TODO Querying a Configuration
** TODO Tracking Changes of Option Values
* TODO Related Work
  + https://github.com/Shinmera/universal-config/
  + https://github.com/Shinmera/ubiquitous
  + https://docs.python.org/3/library/configparser.htm
  + cl-config

* Settings                                                         :noexport:

#+OPTIONS: H:2 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc

* Footnotes

[fn:1] Typically something like (from lowest to highest priority)

       1. Default values
       2. Configuration file(s) and directories
       3. Environment variables
       4. Commandline options
