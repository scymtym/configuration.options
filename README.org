#+TITLE:       configuration.options README
#+AUTHOR:      Jan Moringen
#+EMAIL:       jmoringe@techfak.uni-bielefeld.de
#+DESCRIPTION:
#+KEYWORDS:    common lisp, options, configuration
#+LANGUAGE:    en

* STARTED Introduction
  The =configuration.options= system provides data structures and
  functions for configuration options, sources of option values and
  handling of changes of option values.

  #+ATTR_HTML: :alt "build status image" :title Build Status :align right
  [[https://travis-ci.org/scymtym/configuration.options][https://travis-ci.org/scymtym/configuration.options.svg]]

* STARTED Tutorial
  Implementing configuration processing using the
  =configuration.options= system involves at least three steps
  1. Specifying a schema
  2. Constructing and population a configuration based on the schema
  3. Querying options in the constructed configuration
** TODO Names

** STARTED Specifying a Schema
   A schema can be defined in at least three ways:

   1. "Manually" via multiple function and method calls
   2. Declaratively using ~configuration.options:eval-schema-spec~
   3. Declaratively using ~configuration.options:define-schema~

   Since the second and third methods use the same syntax, it is
   sufficient to discuss ~configuration.options:define-schema~. Here
   is an example:
   #+BEGIN_SRC lisp :results silent :exports both
     (configuration.options:define-schema *my-schema*
       "Configuration schema for my program."
       ("logging"
        ("appender"                :type '(member :file :standard-output)
                                   :default :standard-output
                                   :documentation
                                   "Appender to use.")
        ((:wild-inferiors "level") :type    '(member :info :warning :error)
                                   :documentation
                                   "Package/module/component log level.")))
   #+END_SRC
   The above code creates a schema object and stores it in the
   parameter ~*my-schema*~. The schema consists of two items:

   1. ~logging.appender~ with allowed values ~:file~ and
      ~:standard-output~ with default value ~:standard-output~

   2. a "template" option named =logging.**.level= with allowed values
      ~:info~, ~:warning~ and ~:error~ and without a default value

   #+BEGIN_SRC lisp :results output :exports both
     (describe *my-schema*)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   <root>
   │ Configuration schema for my program.
   └─logging
     ├─appender
     │   Type    (MEMBER FILE STANDARD-OUTPUT)
     │   Default :STANDARD-OUTPUT
     │   Appender to use.
     └─**
       └─level
           Type    (MEMBER INFO WARNING ERROR)
           Default <no default>
           Package/module/component log level.
#+end_example

*** TODO Sub-schemata

** Populating a Configuration
   Configurations are created from schemata by first creating an empty
   configuration object and then populating it with option objects
   corresponding to schema item objects in the schema:

   #+BEGIN_SRC lisp :results silent :exports both
     (defparameter *my-configuration* (configuration.options:make-configuration *my-schema*))
   #+END_SRC

   The created configuration is empty:

   #+BEGIN_SRC lisp :results output :exports both
   (describe *my-configuration*)
   (format t "^ empty configuration (no output)~%")
   #+END_SRC

   #+RESULTS:
   : ^ empty configuration (no output)

   There are several ways to create option objects from schema item
   objects:

   1. "Manually", options can be created using the ~make-option~
      generic function (this also works if the corresponding to schema
      items have wild names):

      #+BEGIN_SRC lisp :exports both
        (let* ((name        "logging.mypackage.myparser.level")
               (schema-item (configuration.options:find-option
                             name *my-schema* :match-wildcards? t)))
          (setf (configuration.options:find-option name *my-configuration*)
                (configuration.options:make-option schema-item name)))
      #+END_SRC

      #+RESULTS:
      : #<STANDARD-OPTION  logging.mypackage.myparser.level: (MEMBER INFO WARNING ERROR) <no value> {100B8A4FE3}>

      Note that the schema item named =logging.**.level= matches the
      requested name because of its ~:wild-inferiors~ name
      component. Also note that creating an option object does not
      automatically assign a value to it (even if the schema item
      specifies a default value).

      The schema item lookup and ~make-option~ call in the above code
      can be done automatically, shortening the example to:

      #+BEGIN_SRC lisp :exports both
        (configuration.options:find-option
         "logging.mypackage.mylexer.level" *my-configuration*
         :if-does-not-exist :create)
      #+END_SRC

      #+RESULTS:
      : #<STANDARD-OPTION  logging.mypackage.mylexer.level: (MEMBER INFO WARNING ERROR) <no value> {100B8DD5C3}>

   2. Using a "synchronizer" which integrates data from sources such
      as configuration files into configuration objects:

      #+BEGIN_SRC lisp :results silent :exports both
        (let ((synchronizer (make-instance 'configuration.options:standard-synchronizer
                                           :target *my-configuration*))
              (source       (configuration.options.sources:make-source :defaults)))
          (configuration.options.sources:initialize source *my-schema*)
          (configuration.options.sources:process source synchronizer))
      #+END_SRC

      The above example uses the simple "default values" source which
      instantiates option objects for all schema items with non-wild
      names and sets their values to the respective default values (if
      any) stored in corresponding schema items.

   After creating these option objects, the configuration looks like
   this:

   #+BEGIN_SRC lisp :results output :exports both
     (describe *my-configuration*)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   <root>
   └─logging
     ├─appender
     │   Type    (MEMBER FILE STANDARD-OUTPUT)
     │   Default :STANDARD-OUTPUT
     │   Value   :STANDARD-OUTPUT
     │   Sources DEFAULT:
     │             :STANDARD-OUTPUT
     │   Appender to use.
     └─mypackage
       ├─mylexer
       │ └─level
       │     Type    (MEMBER INFO WARNING ERROR)
       │     Default <no default>
       │     Value   <no value>
       │     Package/module/component log level.
       └─myparser
         └─level
             Type    (MEMBER INFO WARNING ERROR)
             Default <no default>
             Value   <no value>
             Package/module/component log level.
#+end_example

   In a more realistic setting, populating the configuration would be
   done exclusively using a synchronizer but with a "cascade" of
   sources [fn:1] instead of just the "default values" source.

** TODO Querying a Configuration
** TODO Tracking Changes of Option Values
* TODO Related Work
  + https://github.com/Shinmera/universal-config/
  + https://github.com/Shinmera/ubiquitous
  + https://docs.python.org/3/library/configparser.htm
  + cl-config
* Settings                                                         :noexport:

#+OPTIONS: H:2 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc

* Footnotes

[fn:1] Typically something like (from lowest to highest priority)

       1. Default values
       2. Configuration file(s) and directories
       3. Environment variables
       4. Commandline options
